The project consists of a source code file (coordinator.cpp), a header file (coordinator.h) and a makefile file for compilation. The basic idea of ​​the program is presented below:

The main starts with the arguments() function, with which we pass the arguments given from the command line to the structure that holds the entries and the analogy. The analogy number works as follows. If we give the number 5, it means that for 5 readers corresponds one writer. Then through the create_resources() function we reserve space for the shared memory and for the corresponding semantics of the database. Then we use semaphores_init() to initialize the semaphores and reset the reader and record counters of each entry. Conventionally the number of processes (PEERS_NUM) is 10, so for each process we check if it is a child and then we call the function peer(). First we hold in the analog variable (a random -on time-) value that we divide by analogy + 1 to return a number (To see if we will have access to readers or writers each time). If the analog < rand() (greater frequency), then we will enter the reader function. The reader function briefly calculates the reading time and increases each reader's meter, taking appropriate precautions to block the entry of other readers before taking action (known reader-writers algorithm with rc index) using a mutex that does it up / down per case.If analog > rand() then we call the writer() function where we write data by calling again a corresponding semaphore for the database and entering it up / down to block the rest that should not enter the code segment, returning the residence time. The time_distribution() function returns the time that a reader or writer will "sleep" so that there is no confusion between them. At the end, peer() prints the statistics of each process (for how many readers / writers were created, ie the access time). So after all the peers are done we make a wait on line 266 to let the children processes terminate (no zombie processes) and then for all the entries we collect the statistics on how many were the total readers and how many the writers (Scanning all release the memory that has been blocked by the free_resources() function and terminate the program by also releasing-terminating the parent process.

coordinator.h: This contains the necessary libraries that are needed as well as the defines of the keys that we use to allocate shared memory along with the declarations of the functions that are executed in coordinator.cpp. Additionally there are Args structures where we hold the entries, analogy-entry arguments with the number of readers, writers and the rc variable for input control, the rest of the semantic statements and a union needed for the memory entry functions.

Compile command: 'make' and 'make clean' to clean object files.

Execution Command: './coor -e num1 -a num2' (-e = entries, -a = analogy. If the arguments are less or more an appropriate message is returned).

Implementation language: C++
Tested in Linux environment